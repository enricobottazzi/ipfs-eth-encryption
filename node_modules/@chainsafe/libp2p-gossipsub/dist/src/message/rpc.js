/* eslint-disable import/export */
/* eslint-disable @typescript-eslint/no-namespace */
import { encodeMessage, decodeMessage, message, bool, string, bytes, uint64 } from 'protons-runtime';
export var RPC;
(function (RPC) {
    let SubOpts;
    (function (SubOpts) {
        SubOpts.codec = () => {
            return message({
                1: { name: 'subscribe', codec: bool, optional: true },
                2: { name: 'topic', codec: string, optional: true }
            });
        };
        SubOpts.encode = (obj) => {
            return encodeMessage(obj, SubOpts.codec());
        };
        SubOpts.decode = (buf) => {
            return decodeMessage(buf, SubOpts.codec());
        };
    })(SubOpts = RPC.SubOpts || (RPC.SubOpts = {}));
    let Message;
    (function (Message) {
        Message.codec = () => {
            return message({
                1: { name: 'from', codec: bytes, optional: true },
                2: { name: 'data', codec: bytes, optional: true },
                3: { name: 'seqno', codec: bytes, optional: true },
                4: { name: 'topic', codec: string },
                5: { name: 'signature', codec: bytes, optional: true },
                6: { name: 'key', codec: bytes, optional: true }
            });
        };
        Message.encode = (obj) => {
            return encodeMessage(obj, Message.codec());
        };
        Message.decode = (buf) => {
            return decodeMessage(buf, Message.codec());
        };
    })(Message = RPC.Message || (RPC.Message = {}));
    let ControlMessage;
    (function (ControlMessage) {
        ControlMessage.codec = () => {
            return message({
                1: { name: 'ihave', codec: RPC.ControlIHave.codec(), repeats: true },
                2: { name: 'iwant', codec: RPC.ControlIWant.codec(), repeats: true },
                3: { name: 'graft', codec: RPC.ControlGraft.codec(), repeats: true },
                4: { name: 'prune', codec: RPC.ControlPrune.codec(), repeats: true }
            });
        };
        ControlMessage.encode = (obj) => {
            return encodeMessage(obj, ControlMessage.codec());
        };
        ControlMessage.decode = (buf) => {
            return decodeMessage(buf, ControlMessage.codec());
        };
    })(ControlMessage = RPC.ControlMessage || (RPC.ControlMessage = {}));
    let ControlIHave;
    (function (ControlIHave) {
        ControlIHave.codec = () => {
            return message({
                1: { name: 'topicID', codec: string, optional: true },
                2: { name: 'messageIDs', codec: bytes, repeats: true }
            });
        };
        ControlIHave.encode = (obj) => {
            return encodeMessage(obj, ControlIHave.codec());
        };
        ControlIHave.decode = (buf) => {
            return decodeMessage(buf, ControlIHave.codec());
        };
    })(ControlIHave = RPC.ControlIHave || (RPC.ControlIHave = {}));
    let ControlIWant;
    (function (ControlIWant) {
        ControlIWant.codec = () => {
            return message({
                1: { name: 'messageIDs', codec: bytes, repeats: true }
            });
        };
        ControlIWant.encode = (obj) => {
            return encodeMessage(obj, ControlIWant.codec());
        };
        ControlIWant.decode = (buf) => {
            return decodeMessage(buf, ControlIWant.codec());
        };
    })(ControlIWant = RPC.ControlIWant || (RPC.ControlIWant = {}));
    let ControlGraft;
    (function (ControlGraft) {
        ControlGraft.codec = () => {
            return message({
                1: { name: 'topicID', codec: string, optional: true }
            });
        };
        ControlGraft.encode = (obj) => {
            return encodeMessage(obj, ControlGraft.codec());
        };
        ControlGraft.decode = (buf) => {
            return decodeMessage(buf, ControlGraft.codec());
        };
    })(ControlGraft = RPC.ControlGraft || (RPC.ControlGraft = {}));
    let ControlPrune;
    (function (ControlPrune) {
        ControlPrune.codec = () => {
            return message({
                1: { name: 'topicID', codec: string, optional: true },
                2: { name: 'peers', codec: RPC.PeerInfo.codec(), repeats: true },
                3: { name: 'backoff', codec: uint64, optional: true }
            });
        };
        ControlPrune.encode = (obj) => {
            return encodeMessage(obj, ControlPrune.codec());
        };
        ControlPrune.decode = (buf) => {
            return decodeMessage(buf, ControlPrune.codec());
        };
    })(ControlPrune = RPC.ControlPrune || (RPC.ControlPrune = {}));
    let PeerInfo;
    (function (PeerInfo) {
        PeerInfo.codec = () => {
            return message({
                1: { name: 'peerID', codec: bytes, optional: true },
                2: { name: 'signedPeerRecord', codec: bytes, optional: true }
            });
        };
        PeerInfo.encode = (obj) => {
            return encodeMessage(obj, PeerInfo.codec());
        };
        PeerInfo.decode = (buf) => {
            return decodeMessage(buf, PeerInfo.codec());
        };
    })(PeerInfo = RPC.PeerInfo || (RPC.PeerInfo = {}));
    RPC.codec = () => {
        return message({
            1: { name: 'subscriptions', codec: RPC.SubOpts.codec(), repeats: true },
            2: { name: 'messages', codec: RPC.Message.codec(), repeats: true },
            3: { name: 'control', codec: RPC.ControlMessage.codec(), optional: true }
        });
    };
    RPC.encode = (obj) => {
        return encodeMessage(obj, RPC.codec());
    };
    RPC.decode = (buf) => {
        return decodeMessage(buf, RPC.codec());
    };
})(RPC || (RPC = {}));
//# sourceMappingURL=rpc.js.map