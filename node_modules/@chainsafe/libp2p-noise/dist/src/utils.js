import { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';
import { peerIdFromKeys } from '@libp2p/peer-id';
import { concat as uint8ArrayConcat } from 'uint8arrays/concat';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { pb } from './proto/payload.js';
const NoiseHandshakePayloadProto = pb.NoiseHandshakePayload;
export async function getPayload(localPeer, staticPublicKey, earlyData) {
    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
    const earlyDataPayload = earlyData ?? new Uint8Array(0);
    if (localPeer.publicKey == null) {
        throw new Error('PublicKey was missing from local PeerId');
    }
    return createHandshakePayload(localPeer.publicKey, signedPayload, earlyDataPayload);
}
export function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
    return NoiseHandshakePayloadProto.encode({
        identityKey: libp2pPublicKey,
        identitySig: signedPayload,
        data: earlyData ?? new Uint8Array(0)
    });
}
export async function signPayload(peerId, payload) {
    if (peerId.privateKey == null) {
        throw new Error('PrivateKey was missing from PeerId');
    }
    const privateKey = await unmarshalPrivateKey(peerId.privateKey);
    return await privateKey.sign(payload);
}
export async function getPeerIdFromPayload(payload) {
    return await peerIdFromKeys(payload.identityKey);
}
export function decodePayload(payload) {
    return NoiseHandshakePayloadProto.decode(payload);
}
export function getHandshakePayload(publicKey) {
    const prefix = uint8ArrayFromString('noise-libp2p-static-key:');
    return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length);
}
async function isValidPeerId(peerId, publicKeyProtobuf) {
    const generatedPeerId = await peerIdFromKeys(publicKeyProtobuf);
    return generatedPeerId.equals(peerId);
}
/**
 * Verifies signed payload, throws on any irregularities.
 *
 * @param {bytes} noiseStaticKey - owner's noise static key
 * @param {bytes} payload - decoded payload
 * @param {PeerId} remotePeer - owner's libp2p peer ID
 * @returns {Promise<PeerId>} - peer ID of payload owner
 */
export async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
    const identityKey = payload.identityKey;
    if (!(await isValidPeerId(remotePeer, identityKey))) {
        throw new Error("Peer ID doesn't match libp2p public key.");
    }
    const generatedPayload = getHandshakePayload(noiseStaticKey);
    // Unmarshaling from PublicKey protobuf
    const peerId = await peerIdFromKeys(identityKey);
    if (peerId.publicKey == null) {
        throw new Error('PublicKey was missing from PeerId');
    }
    if (payload.identitySig == null) {
        throw new Error('Signature was missing from message');
    }
    const publicKey = unmarshalPublicKey(peerId.publicKey);
    const valid = await publicKey.verify(generatedPayload, payload.identitySig);
    if (!valid) {
        throw new Error("Static key doesn't match to peer that signed payload!");
    }
    return peerId;
}
export function isValidPublicKey(pk) {
    if (!(pk instanceof Uint8Array)) {
        return false;
    }
    if (pk.length !== 32) {
        return false;
    }
    return true;
}
//# sourceMappingURL=utils.js.map