import type { Multiaddr } from '@multiformats/multiaddr';
import { symbol } from '@libp2p/interfaces/connection';
import type { Connection, ConnectionStat, Metadata, ProtocolStream, Stream } from '@libp2p/interfaces/connection';
import type { PeerId } from '@libp2p/interfaces/peer-id';
import type { AbortOptions } from '@libp2p/interfaces';
interface ConnectionInit {
    remoteAddr: Multiaddr;
    remotePeer: PeerId;
    newStream: (protocols: string[], options?: AbortOptions) => Promise<ProtocolStream>;
    close: () => Promise<void>;
    getStreams: () => Stream[];
    stat: ConnectionStat;
}
/**
 * An implementation of the js-libp2p connection.
 * Any libp2p transport should use an upgrader to return this connection.
 */
export declare class ConnectionImpl implements Connection {
    /**
     * Connection identifier.
     */
    readonly id: string;
    /**
     * Observed multiaddr of the remote peer
     */
    readonly remoteAddr: Multiaddr;
    /**
     * Remote peer id
     */
    readonly remotePeer: PeerId;
    /**
     * Connection metadata
     */
    readonly stat: ConnectionStat;
    /**
     * User provided tags
     *
     */
    tags: string[];
    /**
     * Reference to the new stream function of the multiplexer
     */
    private readonly _newStream;
    /**
     * Reference to the close function of the raw connection
     */
    private readonly _close;
    /**
     * Reference to the getStreams function of the muxer
     */
    private readonly _getStreams;
    /**
     * Connection streams registry
     */
    readonly registry: Map<string, Metadata>;
    private _closing;
    /**
     * An implementation of the js-libp2p connection.
     * Any libp2p transport should use an upgrader to return this connection.
     */
    constructor(init: ConnectionInit);
    get [Symbol.toStringTag](): string;
    get [symbol](): boolean;
    /**
     * Get all the streams of the muxer
     */
    get streams(): Stream[];
    /**
     * Create a new stream from this connection
     */
    newStream(protocols: string | string[], options?: AbortOptions): Promise<{
        stream: Stream;
        protocol: string;
    }>;
    /**
     * Add a stream when it is opened to the registry
     */
    addStream(stream: Stream, metadata?: Partial<Metadata>): void;
    /**
     * Remove stream registry after it is closed
     */
    removeStream(id: string): void;
    /**
     * Close the connection
     */
    close(): Promise<void>;
}
export declare function createConnection(init: ConnectionInit): Connection;
export {};
//# sourceMappingURL=index.d.ts.map