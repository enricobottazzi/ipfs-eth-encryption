import { PubSubBaseProtocol } from '@libp2p/pubsub';
import { multicodec } from './config.js';
import { SimpleTimeCache } from './cache.js';
import type { PubSubInit, Message, PubSubRPC, PubSubRPCMessage, PublishResult } from '@libp2p/interfaces/pubsub';
import type { PeerId } from '@libp2p/interfaces/peer-id';
export { multicodec };
export interface FloodSubInit extends PubSubInit {
    seenTTL?: number;
}
/**
 * FloodSub (aka dumbsub is an implementation of pubsub focused on
 * delivering an API for Publish/Subscribe, but with no CastTree Forming
 * (it just floods the network).
 */
export declare class FloodSub extends PubSubBaseProtocol {
    seenCache: SimpleTimeCache<boolean>;
    constructor(init?: FloodSubInit);
    /**
     * Decode a Uint8Array into an RPC object
     */
    decodeRpc(bytes: Uint8Array): PubSubRPC;
    /**
     * Encode an RPC object into a Uint8Array
     */
    encodeRpc(rpc: PubSubRPC): Uint8Array;
    decodeMessage(bytes: Uint8Array): PubSubRPCMessage;
    encodeMessage(rpc: PubSubRPCMessage): Uint8Array;
    /**
     * Process incoming message
     * Extends base implementation to check router cache.
     */
    processMessage(from: PeerId, message: Message): Promise<void>;
    /**
     * Publish message created. Forward it to the peers.
     */
    publishMessage(from: PeerId, message: Message): Promise<PublishResult>;
}
//# sourceMappingURL=index.d.ts.map