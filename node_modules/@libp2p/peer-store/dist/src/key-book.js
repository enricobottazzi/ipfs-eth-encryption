import { logger } from '@libp2p/logger';
import errcode from 'err-code';
import { codes } from './errors.js';
import { peerIdFromPeerId } from '@libp2p/peer-id';
import { equals as uint8arrayEquals } from 'uint8arrays/equals';
import { CustomEvent } from '@libp2p/interfaces/events';
const log = logger('libp2p:peer-store:key-book');
const EVENT_NAME = 'change:pubkey';
export class PeerStoreKeyBook {
    /**
     * The KeyBook is responsible for keeping the known public keys of a peer
     */
    constructor(dispatchEvent, store) {
        this.dispatchEvent = dispatchEvent;
        this.store = store;
    }
    /**
     * Set the Peer public key
     */
    async set(peerId, publicKey) {
        peerId = peerIdFromPeerId(peerId);
        if (!(publicKey instanceof Uint8Array)) {
            log.error('publicKey must be an instance of Uint8Array to store data');
            throw errcode(new Error('publicKey must be an instance of PublicKey'), codes.ERR_INVALID_PARAMETERS);
        }
        log.trace('set await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('set got write lock');
        let updatedKey = false;
        let peer;
        try {
            try {
                peer = await this.store.load(peerId);
                if ((peer.pubKey != null) && uint8arrayEquals(peer.pubKey, publicKey)) {
                    return;
                }
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            await this.store.patchOrCreate(peerId, {
                pubKey: publicKey
            });
            updatedKey = true;
        }
        finally {
            log.trace('set release write lock');
            release();
        }
        if (updatedKey) {
            this.dispatchEvent(new CustomEvent(EVENT_NAME, {
                detail: {
                    peerId,
                    publicKey: publicKey,
                    oldPublicKey: peer == null ? undefined : peer.pubKey
                }
            }));
        }
    }
    /**
     * Get Public key of the given PeerId, if stored
     */
    async get(peerId) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('get await write lock');
        const release = await this.store.lock.readLock();
        log.trace('get got write lock');
        try {
            const peer = await this.store.load(peerId);
            return peer.pubKey;
        }
        catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
                throw err;
            }
        }
        finally {
            log('get release write lock');
            release();
        }
    }
    async delete(peerId) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('delete await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('delete got write lock');
        let peer;
        try {
            try {
                peer = await this.store.load(peerId);
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            await this.store.patchOrCreate(peerId, {
                pubKey: undefined
            });
        }
        catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
                throw err;
            }
        }
        finally {
            log.trace('delete release write lock');
            release();
        }
        this.dispatchEvent(new CustomEvent(EVENT_NAME, {
            detail: {
                peerId,
                publicKey: undefined,
                oldPublicKey: peer == null ? undefined : peer.pubKey
            }
        }));
    }
}
//# sourceMappingURL=key-book.js.map