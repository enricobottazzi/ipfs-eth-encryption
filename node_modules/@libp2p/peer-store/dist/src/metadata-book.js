import { logger } from '@libp2p/logger';
import errcode from 'err-code';
import { codes } from './errors.js';
import { peerIdFromPeerId } from '@libp2p/peer-id';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { CustomEvent } from '@libp2p/interfaces/events';
const log = logger('libp2p:peer-store:metadata-book');
const EVENT_NAME = 'change:metadata';
export class PeerStoreMetadataBook {
    /**
     * The MetadataBook is responsible for keeping metadata
     * about known peers
     */
    constructor(dispatchEvent, store) {
        this.dispatchEvent = dispatchEvent;
        this.store = store;
    }
    /**
     * Get the known data of a provided peer
     */
    async get(peerId) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('get await read lock');
        const release = await this.store.lock.readLock();
        log.trace('get got read lock');
        try {
            const peer = await this.store.load(peerId);
            return peer.metadata;
        }
        catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
                throw err;
            }
        }
        finally {
            log.trace('get release read lock');
            release();
        }
        return new Map();
    }
    /**
     * Get specific metadata value, if it exists
     */
    async getValue(peerId, key) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('getValue await read lock');
        const release = await this.store.lock.readLock();
        log.trace('getValue got read lock');
        try {
            const peer = await this.store.load(peerId);
            return peer.metadata.get(key);
        }
        catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
                throw err;
            }
        }
        finally {
            log.trace('getValue release write lock');
            release();
        }
    }
    async set(peerId, metadata) {
        peerId = peerIdFromPeerId(peerId);
        if (!(metadata instanceof Map)) {
            log.error('valid metadata must be provided to store data');
            throw errcode(new Error('valid metadata must be provided'), codes.ERR_INVALID_PARAMETERS);
        }
        log.trace('set await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('set got write lock');
        let peer;
        try {
            try {
                peer = await this.store.load(peerId);
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            await this.store.mergeOrCreate(peerId, {
                metadata
            });
        }
        finally {
            log.trace('set release write lock');
            release();
        }
        this.dispatchEvent(new CustomEvent(EVENT_NAME, {
            detail: {
                peerId,
                metadata,
                oldMetadata: peer == null ? new Map() : peer.metadata
            }
        }));
    }
    /**
     * Set metadata key and value of a provided peer
     */
    async setValue(peerId, key, value) {
        peerId = peerIdFromPeerId(peerId);
        if (typeof key !== 'string' || !(value instanceof Uint8Array)) {
            log.error('valid key and value must be provided to store data');
            throw errcode(new Error('valid key and value must be provided'), codes.ERR_INVALID_PARAMETERS);
        }
        log.trace('setValue await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('setValue got write lock');
        let peer;
        let updatedPeer;
        try {
            try {
                peer = await this.store.load(peerId);
                const existingValue = peer.metadata.get(key);
                if (existingValue != null && uint8ArrayEquals(value, existingValue)) {
                    return;
                }
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            updatedPeer = await this.store.mergeOrCreate(peerId, {
                metadata: new Map([[key, value]])
            });
        }
        finally {
            log.trace('setValue release write lock');
            release();
        }
        this.dispatchEvent(new CustomEvent(EVENT_NAME, {
            detail: {
                peerId,
                metadata: updatedPeer.metadata,
                oldMetadata: peer == null ? new Map() : peer.metadata
            }
        }));
    }
    async delete(peerId) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('delete await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('delete got write lock');
        let peer;
        try {
            try {
                peer = await this.store.load(peerId);
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            if (peer != null) {
                await this.store.patch(peerId, {
                    metadata: new Map()
                });
            }
        }
        finally {
            log.trace('delete release write lock');
            release();
        }
        if (peer != null) {
            this.dispatchEvent(new CustomEvent(EVENT_NAME, {
                detail: {
                    peerId,
                    metadata: new Map(),
                    oldMetadata: peer.metadata
                }
            }));
        }
    }
    async deleteValue(peerId, key) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('deleteValue await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('deleteValue got write lock');
        let metadata;
        let peer;
        try {
            peer = await this.store.load(peerId);
            metadata = peer.metadata;
            metadata.delete(key);
            await this.store.patch(peerId, {
                metadata
            });
        }
        catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
                throw err;
            }
        }
        finally {
            log.trace('deleteValue release write lock');
            release();
        }
        if (metadata != null) {
            this.dispatchEvent(new CustomEvent(EVENT_NAME, {
                detail: {
                    peerId,
                    metadata,
                    oldMetadata: peer == null ? new Map() : peer.metadata
                }
            }));
        }
    }
}
//# sourceMappingURL=metadata-book.js.map