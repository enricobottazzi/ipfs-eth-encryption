import { logger } from '@libp2p/logger';
import errcode from 'err-code';
import { codes } from './errors.js';
import { peerIdFromPeerId } from '@libp2p/peer-id';
import { CustomEvent } from '@libp2p/interfaces/events';
const log = logger('libp2p:peer-store:proto-book');
const EVENT_NAME = 'change:protocols';
export class PeerStoreProtoBook {
    /**
     * The ProtoBook is responsible for keeping the known supported
     * protocols of a peer
     */
    constructor(dispatchEvent, store) {
        this.dispatchEvent = dispatchEvent;
        this.store = store;
    }
    async get(peerId) {
        log.trace('get wait for read lock');
        const release = await this.store.lock.readLock();
        log.trace('get got read lock');
        try {
            const peer = await this.store.load(peerId);
            return peer.protocols;
        }
        catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
                throw err;
            }
        }
        finally {
            log.trace('get release read lock');
            release();
        }
        return [];
    }
    async set(peerId, protocols) {
        peerId = peerIdFromPeerId(peerId);
        if (!Array.isArray(protocols)) {
            log.error('protocols must be provided to store data');
            throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);
        }
        log.trace('set await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('set got write lock');
        let peer;
        let updatedPeer;
        try {
            try {
                peer = await this.store.load(peerId);
                if (new Set([
                    ...protocols
                ]).size === peer.protocols.length) {
                    return;
                }
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            updatedPeer = await this.store.patchOrCreate(peerId, {
                protocols
            });
            log('stored provided protocols for %p', peerId);
        }
        finally {
            log.trace('set release write lock');
            release();
        }
        this.dispatchEvent(new CustomEvent(EVENT_NAME, {
            detail: {
                peerId,
                protocols: updatedPeer.protocols,
                oldProtocols: peer == null ? [] : peer.protocols
            }
        }));
    }
    async add(peerId, protocols) {
        peerId = peerIdFromPeerId(peerId);
        if (!Array.isArray(protocols)) {
            log.error('protocols must be provided to store data');
            throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);
        }
        log.trace('add await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('add got write lock');
        let peer;
        let updatedPeer;
        try {
            try {
                peer = await this.store.load(peerId);
                if (new Set([
                    ...peer.protocols,
                    ...protocols
                ]).size === peer.protocols.length) {
                    return;
                }
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            updatedPeer = await this.store.mergeOrCreate(peerId, {
                protocols
            });
            log('added provided protocols for %p', peerId);
        }
        finally {
            log.trace('add release write lock');
            release();
        }
        this.dispatchEvent(new CustomEvent(EVENT_NAME, {
            detail: {
                peerId,
                protocols: updatedPeer.protocols,
                oldProtocols: peer == null ? [] : peer.protocols
            }
        }));
    }
    async remove(peerId, protocols) {
        peerId = peerIdFromPeerId(peerId);
        if (!Array.isArray(protocols)) {
            log.error('protocols must be provided to store data');
            throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);
        }
        log.trace('remove await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('remove got write lock');
        let peer;
        let updatedPeer;
        try {
            try {
                peer = await this.store.load(peerId);
                const protocolSet = new Set(peer.protocols);
                for (const protocol of protocols) {
                    protocolSet.delete(protocol);
                }
                if (peer.protocols.length === protocolSet.size) {
                    return;
                }
                protocols = Array.from(protocolSet);
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            updatedPeer = await this.store.patchOrCreate(peerId, {
                protocols
            });
        }
        finally {
            log.trace('remove release write lock');
            release();
        }
        this.dispatchEvent(new CustomEvent(EVENT_NAME, {
            detail: {
                peerId,
                protocols: updatedPeer.protocols,
                oldProtocols: peer == null ? [] : peer.protocols
            }
        }));
    }
    async delete(peerId) {
        peerId = peerIdFromPeerId(peerId);
        log.trace('delete await write lock');
        const release = await this.store.lock.writeLock();
        log.trace('delete got write lock');
        let peer;
        try {
            try {
                peer = await this.store.load(peerId);
            }
            catch (err) {
                if (err.code !== codes.ERR_NOT_FOUND) {
                    throw err;
                }
            }
            await this.store.patchOrCreate(peerId, {
                protocols: []
            });
        }
        finally {
            log.trace('delete release write lock');
            release();
        }
        if (peer != null) {
            this.dispatchEvent(new CustomEvent(EVENT_NAME, {
                detail: {
                    peerId,
                    protocols: [],
                    oldProtocols: peer.protocols
                }
            }));
        }
    }
}
//# sourceMappingURL=proto-book.js.map