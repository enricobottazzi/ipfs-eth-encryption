import { Key } from 'interface-datastore/key';
import type { Peer } from '@libp2p/interfaces/peer-store';
import type { PeerId } from '@libp2p/interfaces/peer-id';
import { Components } from '@libp2p/interfaces/components';
export interface Store {
    has: (peerId: PeerId) => Promise<boolean>;
    save: (peer: Peer) => Promise<Peer>;
    load: (peerId: PeerId) => Promise<Peer>;
    delete: (peerId: PeerId) => Promise<void>;
    merge: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>;
    mergeOrCreate: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>;
    patch: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>;
    patchOrCreate: (peerId: PeerId, data: Partial<Peer>) => Promise<Peer>;
    all: () => AsyncIterable<Peer>;
    lock: {
        readLock: () => Promise<() => void>;
        writeLock: () => Promise<() => void>;
    };
}
export declare class PersistentStore {
    private components;
    lock: any;
    constructor();
    init(components: Components): void;
    _peerIdToDatastoreKey(peerId: PeerId): Key;
    has(peerId: PeerId): Promise<boolean>;
    delete(peerId: PeerId): Promise<void>;
    load(peerId: PeerId): Promise<Peer>;
    save(peer: Peer): Promise<Peer>;
    patch(peerId: PeerId, data: Partial<Peer>): Promise<Peer>;
    patchOrCreate(peerId: PeerId, data: Partial<Peer>): Promise<Peer>;
    _patch(peerId: PeerId, data: Partial<Peer>, peer: Peer): Promise<Peer>;
    merge(peerId: PeerId, data: Partial<Peer>): Promise<Peer>;
    mergeOrCreate(peerId: PeerId, data: Partial<Peer>): Promise<Peer>;
    _merge(peerId: PeerId, data: Partial<Peer>, peer: Peer): Promise<Peer>;
    all(): AsyncGenerator<Peer, void, unknown>;
}
//# sourceMappingURL=store.d.ts.map