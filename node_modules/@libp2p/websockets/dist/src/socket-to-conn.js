import { abortableSource } from 'abortable-iterator';
import { CLOSE_TIMEOUT } from './constants.js';
import pTimeout from 'p-timeout';
import { logger } from '@libp2p/logger';
const log = logger('libp2p:websockets:socket');
// Convert a stream into a MultiaddrConnection
// https://github.com/libp2p/interface-transport#multiaddrconnection
export function socketToMaConn(stream, remoteAddr, options) {
    options = options ?? {};
    const maConn = {
        async sink(source) {
            if ((options?.signal) != null) {
                source = abortableSource(source, options.signal);
            }
            try {
                await stream.sink(source);
            }
            catch (err) {
                if (err.type !== 'aborted') {
                    log.error(err);
                }
            }
        },
        source: (options.signal != null) ? abortableSource(stream.source, options.signal) : stream.source,
        remoteAddr,
        timeline: { open: Date.now() },
        async close() {
            const start = Date.now();
            try {
                await pTimeout(stream.close(), CLOSE_TIMEOUT);
            }
            catch (err) {
                const { host, port } = maConn.remoteAddr.toOptions();
                log('timeout closing stream to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);
                stream.destroy();
            }
            finally {
                maConn.timeline.close = Date.now();
            }
        }
    };
    stream.socket.once != null && stream.socket.once('close', () => {
        // In instances where `close` was not explicitly called,
        // such as an iterable stream ending, ensure we have set the close
        // timeline
        if (maConn.timeline.close == null) {
            maConn.timeline.close = Date.now();
        }
    });
    return maConn;
}
//# sourceMappingURL=socket-to-conn.js.map