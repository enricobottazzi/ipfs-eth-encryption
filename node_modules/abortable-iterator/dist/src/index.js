import { AbortError } from './abort-error.js';
import { getIterator } from 'get-iterator';
// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort
export function abortableSource(source, signal, options) {
    const opts = options ?? {};
    const iterator = getIterator(source);
    async function* abortable() {
        let nextAbortHandler;
        const abortHandler = () => {
            if (nextAbortHandler != null)
                nextAbortHandler();
        };
        signal.addEventListener('abort', abortHandler);
        while (true) {
            let result;
            try {
                if (signal.aborted) {
                    const { abortMessage, abortCode } = opts;
                    throw new AbortError(abortMessage, abortCode);
                }
                const abort = new Promise((resolve, reject) => {
                    nextAbortHandler = () => {
                        const { abortMessage, abortCode } = opts;
                        reject(new AbortError(abortMessage, abortCode));
                    };
                });
                // Race the iterator and the abort signals
                result = await Promise.race([abort, iterator.next()]);
                nextAbortHandler = null;
            }
            catch (err) {
                signal.removeEventListener('abort', abortHandler);
                // Might not have been aborted by a known signal
                const isKnownAborter = err.type === 'aborted' && signal.aborted;
                if (isKnownAborter && (opts.onAbort != null)) {
                    // Do any custom abort handling for the iterator
                    await opts.onAbort(source);
                }
                // End the iterator if it is a generator
                if (typeof iterator.return === 'function') {
                    try {
                        const p = iterator.return();
                        if (p instanceof Promise) { // eslint-disable-line max-depth
                            p.catch(err => {
                                if (opts.onReturnError != null) {
                                    opts.onReturnError(err);
                                }
                            });
                        }
                    }
                    catch (err) {
                        if (opts.onReturnError != null) { // eslint-disable-line max-depth
                            opts.onReturnError(err);
                        }
                    }
                }
                if (isKnownAborter && opts.returnOnAbort === true) {
                    return;
                }
                throw err;
            }
            if (result.done === true) {
                break;
            }
            yield result.value;
        }
        signal.removeEventListener('abort', abortHandler);
    }
    return abortable();
}
export function abortableSink(sink, signal, options) {
    return (source) => sink(abortableSource(source, signal, options));
}
export function abortableDuplex(duplex, signal, options) {
    return {
        sink: abortableSink(duplex.sink, signal, {
            ...options,
            onAbort: undefined
        }),
        source: abortableSource(duplex.source, signal, options)
    };
}
export { AbortError };
export { abortableSink as abortableTransform };
//# sourceMappingURL=index.js.map