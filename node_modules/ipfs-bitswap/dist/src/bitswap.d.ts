/**
 * JavaScript implementation of the Bitswap 'data exchange' protocol
 * used by IPFS.
 *
 * @implements {IPFSBitswap}
 */
export class Bitswap extends BaseBlockstore implements IPFSBitswap {
    /**
     * @param {import('libp2p').Libp2p} libp2p
     * @param {Blockstore} blockstore
     * @param {object} [options]
     * @param {boolean} [options.statsEnabled=false]
     * @param {number} [options.statsComputeThrottleTimeout=1000]
     * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]
     * @param {MultihashHasherLoader} [options.hashLoader]
     */
    constructor(libp2p: import('libp2p').Libp2p, blockstore: Blockstore, options?: {
        statsEnabled?: boolean | undefined;
        statsComputeThrottleTimeout?: number | undefined;
        statsComputeThrottleMaxQueueSize?: number | undefined;
        hashLoader?: import("./types").MultihashHasherLoader | undefined;
    } | undefined);
    _libp2p: import("libp2p").Libp2p;
    _log: import("debug").Debugger & {
        error: import("debug").Debugger;
    };
    _options: {
        statsEnabled: boolean;
        statsComputeThrottleTimeout: number;
        statsComputeThrottleMaxQueueSize: number;
    } & {
        statsEnabled?: boolean | undefined;
        statsComputeThrottleTimeout?: number | undefined;
        statsComputeThrottleMaxQueueSize?: number | undefined;
        hashLoader?: import("./types").MultihashHasherLoader | undefined;
    };
    _stats: Stats;
    network: Network;
    blockstore: import("interface-blockstore").Blockstore;
    engine: DecisionEngine;
    wm: WantManager;
    notifications: Notifications;
    started: boolean;
    isStarted(): boolean;
    /**
     * @type {PeerId}
     */
    get peerId(): import("@libp2p/interfaces/peer-id").PeerId;
    /**
     * handle messages received through the network
     *
     * @param {PeerId} peerId
     * @param {BitswapMessage} incoming
     */
    _receiveMessage(peerId: PeerId, incoming: BitswapMessage): Promise<void>;
    /**
     * @private
     * @param {PeerId} peerId
     * @param {CID} cid
     * @param {Uint8Array} data
     * @param {boolean} wasWanted
     */
    private _handleReceivedBlock;
    /**
     * @private
     * @param {string} peerIdStr
     * @param {CID} cid
     * @param {Uint8Array} data
     * @param {boolean} exists
     */
    private _updateReceiveCounters;
    /**
     * handle errors on the receiving channel
     *
     * @param {Error} err
     */
    _receiveError(err: Error): void;
    /**
     * handle new peers
     *
     * @param {PeerId} peerId
     */
    _onPeerConnected(peerId: PeerId): void;
    /**
     * handle peers being disconnected
     *
     * @param {PeerId} peerId
     */
    _onPeerDisconnected(peerId: PeerId): void;
    enableStats(): void;
    disableStats(): void;
    /**
     * Return the current wantlist for a given `peerId`
     *
     * @param {PeerId} peerId
     * @param {any} [_options]
     */
    wantlistForPeer(peerId: PeerId, _options?: any): Map<string, import("./wantlist/entry.js").WantListEntry>;
    /**
     * Return ledger information for a given `peerId`
     *
     * @param {PeerId} peerId
     */
    ledgerForPeer(peerId: PeerId): {
        peer: import("@libp2p/interfaces/peer-id").PeerId;
        value: number;
        sent: number;
        recv: number;
        exchanged: number;
    } | null;
    /**
     * Fetch a a list of blocks by cid. If the blocks are in the local
     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.
     *
     * @param {AsyncIterable<CID>|Iterable<CID>} cids
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    getMany(cids: AsyncIterable<CID> | Iterable<CID>, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<Uint8Array, void, unknown>;
    /**
     * Removes the given CIDs from the wantlist independent of any ref counts.
     *
     * This will cause all outstanding promises for a given block to reject.
     *
     * If you want to cancel the want for a block without doing that, pass an
     * AbortSignal in to `.get` or `.getMany` and abort it.
     *
     * @param {CID[]|CID} cids
     */
    unwant(cids: CID[] | CID): void;
    /**
     * Removes the given keys from the want list. This may cause pending promises
     * for blocks to never resolve.  If you wish these promises to abort instead
     * call `unwant(cids)` instead.
     *
     * @param {CID[]|CID} cids
     */
    cancelWants(cids: CID[] | CID): void;
    /**
     * Put the given block to the underlying blockstore and
     * send it to nodes that have it in their wantlist.
     *
     * @param {CID} cid
     * @param {Uint8Array} block
     * @param {any} [_options]
     */
    put(cid: CID, block: Uint8Array, _options?: any): Promise<void>;
    /**
     * Put the given blocks to the underlying blockstore and
     * send it to nodes that have it them their wantlist.
     *
     * @param {Iterable<Pair> | AsyncIterable<Pair>} source
     * @param {Options} [options]
     */
    putMany(source: Iterable<Pair> | AsyncIterable<Pair>, options?: import("interface-blockstore").Options | undefined): AsyncGenerator<{
        key: CID;
        value: Uint8Array;
    }, void, unknown>;
    /**
     * Sends notifications about the arrival of a block
     *
     * @private
     * @param {CID} cid
     * @param {Uint8Array} data
     */
    private _sendHaveBlockNotifications;
    /**
     * Get the current list of wants
     */
    getWantlist(): IterableIterator<[string, import("./wantlist/entry.js").WantListEntry]>;
    /**
     * Get the current list of partners
     */
    peers(): import("@libp2p/interfaces/peer-id").PeerId[];
    /**
     * Get stats about the bitswap node
     */
    stat(): Stats;
    /**
     * Start the bitswap node
     */
    start(): Promise<void>;
    /**
     * Stop the bitswap node
     */
    stop(): Promise<void>;
    unwrap(): import("interface-blockstore").Blockstore;
}
export type IPFSBitswap = import('./types').IPFSBitswap;
export type MultihashHasherLoader = import('./types').MultihashHasherLoader;
export type BitswapMessage = import('./message').BitswapMessage;
export type PeerId = import('@libp2p/interfaces/peer-id').PeerId;
export type Blockstore = import('interface-blockstore').Blockstore;
export type Pair = import('interface-blockstore').Pair;
export type Options = import('interface-blockstore').Options;
import { BaseBlockstore } from "blockstore-core/base";
import { Stats } from "./stats/index.js";
import { Network } from "./network.js";
import { DecisionEngine } from "./decision-engine/index.js";
import { WantManager } from "./want-manager/index.js";
import { Notifications } from "./notifications.js";
import { CID } from "multiformats/cid";
//# sourceMappingURL=bitswap.d.ts.map