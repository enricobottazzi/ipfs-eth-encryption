/**
 * @typedef {import('@libp2p/interfaces/peer-id').PeerId} PeerId
 *
 * @typedef {object} ExperimentalOptions
 * @property {boolean} [ipnsPubsub]
 *
 * @typedef {object} LibP2POptions
 * @property {DHTConfig} [config]
 *
 * @typedef {object} DHTConfig
 * @property {boolean} [enabled]
 */
export class IPNSAPI {
    /**
     * @param {object} options
     * @param {string} options.pass
     * @param {boolean} [options.offline]
     * @param {LibP2POptions} [options.libp2p]
     * @param {ExperimentalOptions} [options.EXPERIMENTAL]
     */
    constructor(options?: {
        pass: string;
        offline?: boolean | undefined;
        libp2p?: LibP2POptions | undefined;
        EXPERIMENTAL?: ExperimentalOptions | undefined;
    });
    options: {
        pass: string;
        offline?: boolean | undefined;
        libp2p?: LibP2POptions | undefined;
        EXPERIMENTAL?: ExperimentalOptions | undefined;
    };
    /** @type {IPNS | null} */
    offline: IPNS | null;
    /** @type {IPNS | null} */
    online: IPNS | null;
    getIPNS(): IPNS;
    get routing(): import("ipfs-core-types/dist/src/utils").BufferStore;
    /**
     * Activates IPNS subsystem in an ofline mode. If it was started once already
     * it will throw an exception.
     *
     * This is primarily used for offline ipns modifications, such as the
     * initializeKeyspace feature.
     *
     * @param {object} config
     * @param {import('ipfs-repo').IPFSRepo} config.repo
     * @param {import('@libp2p/interfaces/peer-id').PeerId} config.peerId
     * @param {import('@libp2p/interfaces/keychain').KeyChain} config.keychain
     */
    startOffline({ repo, peerId, keychain }: {
        repo: import('ipfs-repo').IPFSRepo;
        peerId: import('@libp2p/interfaces/peer-id').PeerId;
        keychain: import('@libp2p/interfaces/keychain').KeyChain;
    }): void;
    /**
     * @param {object} config
     * @param {import('libp2p').Libp2p} config.libp2p
     * @param {import('ipfs-repo').IPFSRepo} config.repo
     * @param {import('@libp2p/interfaces/peer-id').PeerId} config.peerId
     * @param {import('@libp2p/interfaces/keychain').KeyChain} config.keychain
     */
    startOnline({ libp2p, repo, peerId, keychain }: {
        libp2p: import('libp2p').Libp2p;
        repo: import('ipfs-repo').IPFSRepo;
        peerId: import('@libp2p/interfaces/peer-id').PeerId;
        keychain: import('@libp2p/interfaces/keychain').KeyChain;
    }): Promise<void>;
    stop(): Promise<void>;
    /**
     * @param {PeerId} peerId
     * @param {Uint8Array} value
     * @param {number} lifetime
     */
    publish(peerId: PeerId, value: Uint8Array, lifetime: number): Promise<{
        name: string;
        value: Uint8Array;
    }>;
    /**
     *
     * @param {string} name
     * @param {*} [options]
     */
    resolve(name: string, options?: any): Promise<any>;
    /**
     * @param {PeerId} peerId
     * @param {Uint8Array} value
     */
    initializeKeyspace(peerId: PeerId, value: Uint8Array): Promise<{
        name: string;
        value: Uint8Array;
    }>;
}
export type PeerId = import('@libp2p/interfaces/peer-id').PeerId;
export type ExperimentalOptions = {
    ipnsPubsub?: boolean | undefined;
};
export type LibP2POptions = {
    config?: DHTConfig | undefined;
};
export type DHTConfig = {
    enabled?: boolean | undefined;
};
import { IPNS } from "../ipns/index.js";
//# sourceMappingURL=ipns.d.ts.map