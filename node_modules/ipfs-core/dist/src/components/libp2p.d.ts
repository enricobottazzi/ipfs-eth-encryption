/**
 * @typedef {object} DekOptions
 * @property {string} hash
 * @property {string} salt
 * @property {number} iterationCount
 * @property {number} keyLength
 *
 * @typedef {object} KeychainConfig
 * @property {string} [pass]
 * @property {DekOptions} [dek]
 *
 * @typedef {import('ipfs-repo').IPFSRepo} Repo
 * @typedef {import('@libp2p/interfaces/peer-id').PeerId} PeerId
 * @typedef {import('../types').Options} IPFSOptions
 * @typedef {import('libp2p').Libp2p} LibP2P
 * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions
 * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig
 */
/**
 * @param {object} config
 * @param {Repo} config.repo
 * @param {IPFSOptions|undefined} config.options
 * @param {PeerId} config.peerId
 * @param {Multiaddr[]|undefined} config.multiaddrs
 * @param {KeychainConfig|undefined} config.keychainConfig
 * @param {Partial<IPFSConfig>|undefined} config.config
 */
export function createLibp2p({ options, peerId, multiaddrs, repo, keychainConfig, config }: {
    repo: Repo;
    options: IPFSOptions | undefined;
    peerId: PeerId;
    multiaddrs: Multiaddr[] | undefined;
    keychainConfig: KeychainConfig | undefined;
    config: Partial<IPFSConfig> | undefined;
}): Promise<import("libp2p").Libp2p>;
export type DekOptions = {
    hash: string;
    salt: string;
    iterationCount: number;
    keyLength: number;
};
export type KeychainConfig = {
    pass?: string | undefined;
    dek?: DekOptions | undefined;
};
export type Repo = import('ipfs-repo').IPFSRepo;
export type PeerId = import('@libp2p/interfaces/peer-id').PeerId;
export type IPFSOptions = import('../types').Options;
export type LibP2P = import('libp2p').Libp2p;
export type Libp2pOptions = import('libp2p').Libp2pOptions;
export type IPFSConfig = import('ipfs-core-types/src/config').Config;
import { Multiaddr } from "@multiformats/multiaddr";
//# sourceMappingURL=libp2p.d.ts.map