export class NameAPI {
    /**
     * @param {object} config
     * @param {import('../ipns').IPNSAPI} config.ipns
     * @param {import('@libp2p/interfaces/peer-id').PeerId} config.peerId
     * @param {import('../../types').Options} config.options
     * @param {import('ipfs-repo').IPFSRepo} config.repo
     * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
     * @param {import('ipfs-core-types/src/root').API<{}>["isOnline"]} config.isOnline
     * @param {import('@libp2p/interfaces/keychain').KeyChain} config.keychain
     * @param {import('ipfs-core-types/src/root').API<{}>["dns"]} config.dns
     */
    constructor({ dns, ipns, repo, codecs, peerId, isOnline, keychain, options }: {
        ipns: import('../ipns').IPNSAPI;
        peerId: import('@libp2p/interfaces/peer-id').PeerId;
        options: import('../../types').Options;
        repo: import('ipfs-repo').IPFSRepo;
        codecs: import('ipfs-core-utils/multicodecs').Multicodecs;
        isOnline: import('ipfs-core-types/src/root').API<{}>["isOnline"];
        keychain: import('@libp2p/interfaces/keychain').KeyChain;
        dns: import('ipfs-core-types/src/root').API<{}>["dns"];
    });
    publish: (value: string | import("multiformats").CID, options?: import("ipfs-core-types/dist/src/name").PublishOptions | undefined) => Promise<import("ipfs-core-types/dist/src/name").PublishResult>;
    resolve: (name: string | import("@libp2p/interfaces/peer-id").PeerId, options?: import("ipfs-core-types/dist/src/name").ResolveOptions | undefined) => AsyncIterable<string>;
    pubsub: PubSubAPI;
}
import { PubSubAPI } from "./pubsub/index.js";
//# sourceMappingURL=index.d.ts.map