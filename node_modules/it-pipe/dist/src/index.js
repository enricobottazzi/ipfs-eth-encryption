import { pushable } from 'it-pushable';
import merge from 'it-merge';
export const rawPipe = (...fns) => {
    let res;
    while (fns.length > 0) {
        res = fns.shift()(res);
    }
    return res;
};
export const isIterable = (obj) => {
    return obj != null && (typeof obj[Symbol.asyncIterator] === 'function' ||
        typeof obj[Symbol.iterator] === 'function' ||
        typeof obj.next === 'function' // Probably, right?
    );
};
export const isDuplex = (obj) => {
    return obj != null && typeof obj.sink === 'function' && isIterable(obj.source);
};
const duplexPipelineFn = (duplex) => {
    return (source) => {
        const p = duplex.sink(source);
        if (p.then != null) {
            const stream = pushable();
            p.then(() => {
                stream.end();
            }, (err) => {
                stream.end(err);
            });
            const sourceWrap = async function* () {
                yield* duplex.source;
                stream.end();
            };
            return merge(stream, sourceWrap());
        }
        return duplex.source;
    };
};
export function pipe(first, ...rest) {
    // Duplex at start: wrap in function and return duplex source
    if (isDuplex(first)) {
        const duplex = first;
        first = () => duplex.source;
        // Iterable at start: wrap in function
    }
    else if (isIterable(first)) {
        const source = first;
        first = () => source;
    }
    const fns = [first, ...rest];
    if (fns.length > 1) {
        // Duplex at end: use duplex sink
        if (isDuplex(fns[fns.length - 1])) {
            fns[fns.length - 1] = fns[fns.length - 1].sink;
        }
    }
    if (fns.length > 2) {
        // Duplex in the middle, consume source with duplex sink and return duplex source
        for (let i = 1; i < fns.length - 1; i++) {
            if (isDuplex(fns[i])) {
                fns[i] = duplexPipelineFn(fns[i]);
            }
        }
    }
    return rawPipe(...fns);
}
//# sourceMappingURL=index.js.map