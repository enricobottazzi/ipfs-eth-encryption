import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist';
import { reader } from 'it-reader';
export function lteReader(source) {
    const input = reader(source);
    let overflow;
    const lteReader = {
        [Symbol.asyncIterator]: () => lteReader,
        async next(bytes) {
            if (overflow != null) {
                let value;
                if (bytes == null || overflow.length === bytes) {
                    value = overflow;
                    overflow = null;
                }
                else if (overflow.length > bytes) {
                    value = overflow.subarray(0, bytes);
                    overflow = overflow.subarray(bytes);
                }
                else if (overflow.length < bytes) {
                    const { value: nextValue, done } = await input.next(bytes - overflow.length);
                    if (done === true ?? nextValue == null) {
                        throw Object.assign(new Error(`stream ended before ${bytes - overflow.length} bytes became available`), { code: 'ERR_UNDER_READ' });
                    }
                    value = new Uint8ArrayList(overflow, nextValue);
                    overflow = null;
                }
                if (value == null) {
                    const result = { done: true, value: undefined };
                    return result;
                }
                const result = { done: false, value };
                return result;
            }
            return await input.next(bytes);
        },
        async nextLte(bytes) {
            const { done, value } = await lteReader.next();
            if (done === true) {
                return {
                    done: true,
                    value: undefined
                };
            }
            if (value.length <= bytes) {
                return { done: false, value };
            }
            const list = isUint8ArrayList(value) ? value : new Uint8ArrayList(value);
            if (overflow != null) {
                overflow.append(list.subarray(bytes));
            }
            else {
                overflow = list.subarray(bytes);
            }
            return { done: false, value: list.subarray(0, bytes) };
        },
        async return() {
            return await input.return();
        }
    };
    return lteReader;
}
//# sourceMappingURL=lte-reader.js.map