import { SummaryObject } from './latency-monitor.js';
import type { AbortOptions } from '@libp2p/interfaces';
import { EventEmitter } from '@libp2p/interfaces/events';
import type { Startable } from '@libp2p/interfaces/startable';
import { PeerId } from '@libp2p/interfaces/peer-id';
import type { Connection } from '@libp2p/interfaces/connection';
import type { ConnectionManager } from '@libp2p/interfaces/connection-manager';
import { Components, Initializable } from '@libp2p/interfaces/components';
import { Dialer } from './dialer/index.js';
import type { AddressSorter } from '@libp2p/interfaces/peer-store';
import type { Resolver } from '@multiformats/multiaddr';
export interface ConnectionManagerInit {
    /**
     * The maximum number of connections to keep open
     */
    maxConnections: number;
    /**
     * The minimum number of connections to keep open
     */
    minConnections: number;
    /**
     * The max data (in and out), per average interval to allow
     */
    maxData?: number;
    /**
     * The max outgoing data, per average interval to allow
     */
    maxSentData?: number;
    /**
     * The max incoming data, per average interval to allow
     */
    maxReceivedData?: number;
    /**
     * The upper limit the event loop can take to run
     */
    maxEventLoopDelay?: number;
    /**
     * How often, in milliseconds, metrics and latency should be checked
     */
    pollInterval?: number;
    /**
     * How often, in milliseconds, to compute averages
     */
    movingAverageInterval?: number;
    /**
     * The value of the peer
     */
    defaultPeerValue?: number;
    /**
     * If true, try to connect to all discovered peers up to the connection manager limit
     */
    autoDial?: boolean;
    /**
     * How long to wait between attempting to keep our number of concurrent connections
     * above minConnections
     */
    autoDialInterval: number;
    /**
     * Sort the known addresses of a peer before trying to dial
     */
    addressSorter?: AddressSorter;
    /**
     * Number of max concurrent dials
     */
    maxParallelDials?: number;
    /**
     * Number of max addresses to dial for a given peer
     */
    maxAddrsToDial?: number;
    /**
     * How long a dial attempt is allowed to take
     */
    dialTimeout?: number;
    /**
     * Number of max concurrent dials per peer
     */
    maxDialsPerPeer?: number;
    /**
     * Multiaddr resolvers to use when dialing
     */
    resolvers?: Record<string, Resolver>;
}
export interface ConnectionManagerEvents {
    'peer:connect': CustomEvent<PeerId>;
    'peer:disconnect': CustomEvent<PeerId>;
}
/**
 * Responsible for managing known connections.
 */
export declare class DefaultConnectionManager extends EventEmitter<ConnectionManagerEvents> implements ConnectionManager, Startable, Initializable {
    readonly dialer: Dialer;
    private components;
    private readonly opts;
    private readonly peerValues;
    private readonly connections;
    private started;
    private timer?;
    private readonly latencyMonitor;
    constructor(init: ConnectionManagerInit);
    init(components: Components): void;
    isStarted(): boolean;
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    start(): Promise<void>;
    afterStart(): Promise<void>;
    beforeStop(): Promise<void>;
    /**
     * Stops the Connection Manager
     */
    stop(): Promise<void>;
    /**
     * Cleans up the connections
     */
    _close(): Promise<void>;
    /**
     * Sets the value of the given peer. Peers with lower values
     * will be disconnected first.
     */
    setPeerValue(peerId: PeerId, value: number): void;
    /**
     * Checks the libp2p metrics to determine if any values have exceeded
     * the configured maximums.
     *
     * @private
     */
    _checkMetrics(): Promise<void>;
    onConnect(evt: CustomEvent<Connection>): void;
    /**
     * Tracks the incoming connection and check the connection limit
     */
    _onConnect(evt: CustomEvent<Connection>): Promise<void>;
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt: CustomEvent<Connection>): void;
    getConnections(peerId?: PeerId): Connection[];
    openConnection(peerId: PeerId, options?: AbortOptions): Promise<Connection>;
    closeConnections(peerId: PeerId): Promise<void>;
    /**
     * Get all open connections with a peer
     */
    getAll(peerId: PeerId): Connection[];
    /**
     * If the event loop is slow, maybe close a connection
     */
    _onLatencyMeasure(evt: CustomEvent<SummaryObject>): void;
    /**
     * If the `value` of `name` has exceeded its limit, maybe close a connection
     */
    _checkMaxLimit(name: keyof ConnectionManagerInit, value: number, toPrune?: number): Promise<void>;
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    _maybePruneConnections(toPrune: number): Promise<void>;
}
//# sourceMappingURL=index.d.ts.map