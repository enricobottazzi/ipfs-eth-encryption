/**
 * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)
 */
import { EventEmitter } from '@libp2p/interfaces/events';
export interface LatencyMonitorEvents {
    'data': CustomEvent<SummaryObject>;
}
export interface LatencyMonitorInit {
    /**
     * How often to add a latency check event (ms)
     */
    latencyCheckIntervalMs?: number;
    /**
     * How often to summarize latency check events. null or 0 disables event firing
     */
    dataEmitIntervalMs?: number;
    /**
     * What cb-style async function to use
     */
    asyncTestFn?: (cb: () => void) => void;
    /**
     * What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.
     */
    latencyRandomPercentage?: number;
}
export interface SummaryObject {
    /**
     * How many events were called
     */
    events: number;
    /**
     * What was the min time for a cb to be called
     */
    minMs: number;
    /**
     * What was the max time for a cb to be called
     */
    maxMs: number;
    /**
     * What was the average time for a cb to be called
     */
    avgMs: number;
    /**
     * How long this interval was in ms
     */
    lengthMs: number;
}
interface LatencyData {
    startTime: number;
    events: number;
    minMs: number;
    maxMs: number;
    totalMs: number;
}
/**
 * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling
 * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.
 * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.
 *
 * @extends {EventEmitter}
 *
 * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop
 * and timing how long it takes to get back.
 *
 * @example
 * const monitor = new LatencyMonitor();
 * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));
 *
 * @example
 * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});
 * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));
 */
export declare class LatencyMonitor extends EventEmitter<LatencyMonitorEvents> {
    private readonly latencyCheckIntervalMs;
    private readonly latencyRandomPercentage;
    private readonly latencyCheckMultiply;
    private readonly latencyCheckSubtract;
    private readonly dataEmitIntervalMs?;
    private readonly asyncTestFn?;
    private readonly now;
    private readonly getDeltaMS;
    private visibilityChangeEmitter?;
    private latencyData;
    private checkLatencyID?;
    private emitIntervalID?;
    constructor(init?: LatencyMonitorInit);
    start(): void;
    stop(): void;
    /**
     * Start internal timers
     *
     * @private
     */
    _startTimers(): void;
    /**
     * Stop internal timers
     *
     * @private
     */
    _stopTimers(): void;
    /**
     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show
     *
     * @private
     */
    _emitSummary(): void;
    /**
     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,
     * it will not count for this time period
     */
    getSummary(): SummaryObject;
    /**
     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,
     * it will simply report on event loop latency.
     */
    checkLatency(): void;
    initLatencyData(): LatencyData;
}
export {};
//# sourceMappingURL=latency-monitor.d.ts.map