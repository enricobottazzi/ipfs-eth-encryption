import type { AbortOptions } from '@libp2p/interfaces';
import { EventEmitter } from '@libp2p/interfaces/events';
import type { Multiaddr } from '@multiformats/multiaddr';
import { KeyChain } from './keychain/index.js';
import { IdentifyService } from './identify/index.js';
import { FetchService } from './fetch/index.js';
import { PingService } from './ping/index.js';
import { Components } from '@libp2p/interfaces/components';
import type { PeerId } from '@libp2p/interfaces/peer-id';
import type { Connection } from '@libp2p/interfaces/connection';
import type { PeerRouting } from '@libp2p/interfaces/peer-routing';
import type { ContentRouting } from '@libp2p/interfaces/content-routing';
import type { PubSub } from '@libp2p/interfaces/pubsub';
import type { Registrar, StreamHandler } from '@libp2p/interfaces/registrar';
import type { ConnectionManager } from '@libp2p/interfaces/connection-manager';
import type { PeerInfo } from '@libp2p/interfaces/peer-info';
import type { Libp2p, Libp2pEvents, Libp2pInit, Libp2pOptions } from './index.js';
import type { PeerStore } from '@libp2p/interfaces/peer-store';
import type { DualDHT } from '@libp2p/interfaces/dht';
import type { Metrics } from '@libp2p/interfaces/metrics';
export declare class Libp2pNode extends EventEmitter<Libp2pEvents> implements Libp2p {
    peerId: PeerId;
    dht: DualDHT;
    pubsub: PubSub;
    identifyService?: IdentifyService;
    fetchService: FetchService;
    pingService: PingService;
    components: Components;
    peerStore: PeerStore;
    contentRouting: ContentRouting;
    peerRouting: PeerRouting;
    keychain: KeyChain;
    connectionManager: ConnectionManager;
    registrar: Registrar;
    metrics?: Metrics;
    private started;
    private readonly services;
    private readonly initializables;
    constructor(init: Libp2pInit);
    private configureComponent;
    /**
     * Starts the libp2p node and all its subsystems
     */
    start(): Promise<void>;
    /**
     * Stop the libp2p node by closing its listeners and open connections
     */
    stop(): Promise<void>;
    /**
     * Load keychain keys from the datastore.
     * Imports the private key as 'self', if needed.
     */
    loadKeychain(): Promise<void>;
    isStarted(): boolean;
    getConnections(peerId?: PeerId): Connection[];
    getPeers(): PeerId[];
    dial(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<Connection>;
    dialProtocol(peer: PeerId | Multiaddr, protocols: string | string[], options?: AbortOptions): Promise<import("@libp2p/interfaces/connection").ProtocolStream>;
    getMultiaddrs(): Multiaddr[];
    hangUp(peer: PeerId | Multiaddr | string): Promise<void>;
    /**
     * Get the public key for the given peer id
     */
    getPublicKey(peer: PeerId, options?: AbortOptions): Promise<Uint8Array>;
    fetch(peer: PeerId | Multiaddr | string, key: string, options?: AbortOptions): Promise<Uint8Array | null>;
    ping(peer: PeerId | Multiaddr | string, options?: AbortOptions): Promise<number>;
    handle(protocols: string | string[], handler: StreamHandler): Promise<void>;
    unhandle(protocols: string[] | string): Promise<void>;
    /**
     * Called whenever peer discovery services emit `peer` events.
     * Known peers may be emitted.
     */
    onDiscoveryPeer(evt: CustomEvent<PeerInfo>): void;
}
/**
 * Returns a new Libp2pNode instance - this exposes more of the internals than the
 * libp2p interface and is useful for testing and debugging.
 */
export declare function createLibp2pNode(options: Libp2pOptions): Promise<Libp2pNode>;
//# sourceMappingURL=libp2p.d.ts.map