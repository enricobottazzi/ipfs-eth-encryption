import { DefaultStats } from './stats.js';
import type { ComponentMetricsUpdate, Metrics, Stats, TrackStreamOptions } from '@libp2p/interfaces/metrics';
import type { PeerId } from '@libp2p/interfaces/peer-id';
import type { Startable } from '@libp2p/interfaces/startable';
import type { Duplex } from 'it-stream-types';
export interface OnMessageOptions {
    remotePeer: PeerId;
    protocol?: string;
    direction: 'in' | 'out';
    dataLength: number;
}
export interface MetricsInit {
    enabled: boolean;
    computeThrottleMaxQueueSize: number;
    computeThrottleTimeout: number;
    movingAverageIntervals: number[];
    maxOldPeersRetention: number;
}
export declare class DefaultMetrics implements Metrics, Startable {
    globalStats: DefaultStats;
    private readonly enabled;
    private readonly peerStats;
    private readonly protocolStats;
    private readonly oldPeers;
    private running;
    private readonly systems;
    private readonly statsInit;
    constructor(init: MetricsInit);
    isStarted(): boolean;
    /**
     * Must be called for stats to saved. Any data pushed for tracking
     * will be ignored.
     */
    start(): Promise<void>;
    /**
     * Stops all averages timers and prevents new data from being tracked.
     * Once `stop` is called, `start` must be called to resume stats tracking.
     */
    stop(): Promise<void>;
    /**
     * Gets the global `Stats` object
     */
    getGlobal(): DefaultStats;
    /**
     * Returns a list of `PeerId` strings currently being tracked
     */
    getPeers(): string[];
    getComponentMetrics(): Map<string, Map<string, Map<string, number>>>;
    updateComponentMetric(update: ComponentMetricsUpdate): void;
    /**
     * Returns the `Stats` object for the given `PeerId` whether it
     * is a live peer, or in the disconnected peer LRU cache.
     */
    forPeer(peerId: PeerId): Stats | undefined;
    /**
     * Returns a list of all protocol strings currently being tracked
     */
    getProtocols(): string[];
    /**
     * Returns the `Stats` object for the given `protocol`
     */
    forProtocol(protocol: string): Stats | undefined;
    /**
     * Should be called when all connections to a given peer
     * have closed. The `Stats` collection for the peer will
     * be stopped and moved to an LRU for temporary retention.
     */
    onPeerDisconnected(peerId: PeerId): void;
    /**
     * Takes the metadata for a message and tracks it in the
     * appropriate categories. If the protocol is present, protocol
     * stats will also be tracked.
     */
    _onMessage(opts: OnMessageOptions): void;
    /**
     * Replaces the `PeerId` string with the given `peerId`.
     * If stats are already being tracked for the given `peerId`, the
     * placeholder stats will be merged with the existing stats.
     *
     * @param {PeerId} placeholder - A peerId string
     * @param {PeerId} peerId
     * @returns {void}
     */
    updatePlaceholder(placeholder: PeerId, peerId: PeerId): void;
    /**
     * Tracks data running through a given Duplex Iterable `stream`. If
     * the `peerId` is not provided, a placeholder string will be created and
     * returned. This allows lazy tracking of a peer when the peer is not yet known.
     * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called
     * with the placeholder string returned from here, and the known `PeerId`.
     */
    trackStream<T extends Duplex<Uint8Array>>(opts: TrackStreamOptions<T>): T;
}
//# sourceMappingURL=index.d.ts.map