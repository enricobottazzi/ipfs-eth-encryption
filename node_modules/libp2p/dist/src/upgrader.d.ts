import { EventEmitter } from '@libp2p/interfaces/events';
import type { Connection, Stream } from '@libp2p/interfaces/connection';
import type { ConnectionEncrypter, SecuredConnection } from '@libp2p/interfaces/connection-encrypter';
import type { StreamMuxerFactory } from '@libp2p/interfaces/stream-muxer';
import type { PeerId } from '@libp2p/interfaces/peer-id';
import type { MultiaddrConnection, Upgrader, UpgraderEvents } from '@libp2p/interfaces/transport';
import type { Duplex } from 'it-stream-types';
import type { Components } from '@libp2p/interfaces/components';
interface CreateConectionOptions {
    cryptoProtocol: string;
    direction: 'inbound' | 'outbound';
    maConn: MultiaddrConnection;
    upgradedConn: Duplex<Uint8Array>;
    remotePeer: PeerId;
    muxerFactory?: StreamMuxerFactory;
}
interface OnStreamOptions {
    connection: Connection;
    stream: Stream;
    protocol: string;
}
export interface CryptoResult extends SecuredConnection {
    protocol: string;
}
export interface UpgraderInit {
    connectionEncryption: ConnectionEncrypter[];
    muxers: StreamMuxerFactory[];
}
export declare class DefaultUpgrader extends EventEmitter<UpgraderEvents> implements Upgrader {
    private readonly components;
    private readonly connectionEncryption;
    private readonly muxers;
    constructor(components: Components, init: UpgraderInit);
    /**
     * Upgrades an inbound connection
     */
    upgradeInbound(maConn: MultiaddrConnection): Promise<Connection>;
    /**
     * Upgrades an outbound connection
     */
    upgradeOutbound(maConn: MultiaddrConnection): Promise<Connection>;
    /**
     * A convenience method for generating a new `Connection`
     */
    _createConnection(opts: CreateConectionOptions): Connection;
    /**
     * Routes incoming streams to the correct handler
     */
    _onStream(opts: OnStreamOptions): void;
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`
     */
    _encryptInbound(connection: Duplex<Uint8Array>): Promise<CryptoResult>;
    /**
     * Attempts to encrypt the given `connection` with the provided connection encrypters.
     * The first `ConnectionEncrypter` module to succeed will be used
     */
    _encryptOutbound(connection: MultiaddrConnection, remotePeerId: PeerId): Promise<CryptoResult>;
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     */
    _multiplexOutbound(connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{
        stream: Duplex<Uint8Array>;
        muxerFactory?: StreamMuxerFactory;
    }>;
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     */
    _multiplexInbound(connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{
        stream: Duplex<Uint8Array>;
        muxerFactory?: StreamMuxerFactory;
    }>;
}
export {};
//# sourceMappingURL=upgrader.d.ts.map